<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
    <title>Test Charts</title>
    <style>
      body {
        font: 10px sans-serif;
        color: black;
      }
      .graph_container {
        /*position: relative;*/
        margin: 0 auto;
        width: 1800px;
      }
      .column1{
        float: left;
        width: 550px;
      }
      .column2{
        margin-left: 75px;
        float: left;
        width: 550px;
      }
      .column3{
        /*margin-left: 50px;*/
        float: right;
        width: 550px;
      }
      .graph{
        margin-top:50px;
        margin-bottom:50px;
      }
      .axis path,
      .axis line {
        fill: none;
        stroke: #CCC;
        shape-rendering: crispEdges;
      }
      .axis-text {
        color: red;
      }
      .area_value1 {
        /*fill: url(#first-gradient);*/
        fill: #FF6319;
        stroke-width: 0px;
        opacity: 0.6;
      }
      .area_value2 {
        /*fill: url(#second-gradient);*/
        fill: #C60C30;
        stroke-width: 0px;
        opacity: 0.6;
      }
      h1 {
        text-transform: uppercase;
        font-size: 5em;
        background-color: black;
        color: white;
        padding-left: 10px;
      }
      h2 {
        text-transform: uppercase;
        font-size: 3em;
        line-height: 0.3em;
      }
      p {
        font-size: 12px;
        font-weight: normal;
      }
      p.title {
        font-size: 2em;
        font-weight: bold;
        text-transform: uppercase;
        background-color: black;
        color: white;
        padding: 20px;
      }
      span.chiefs {
        color: #C60C30;
      }
      span.broncos {
        color: #FF6319;
      }
    </style>
  </head>
  <body>
    <div class="graph_container">
      <p class="title"><span class="broncos">Broncos</span> vs <span class="chiefs">Chiefs</span><br/> Sunday November 17th</p>
      <div class="column1">
        <h1>Per Hour<br /> - Raw</h1>
        <div id="graph_container_1" class="graph"><h2># Tweets</h2><p>/game/tweets?time=hour&num=24</p></div>
        <div id="graph_container_2" class="graph"><h2>Positive Mentions</h2><p>/game/pos?time=hour&num=24</p></div>
        <div id="graph_container_3" class="graph"><h2>Confidence</h2><p>/game/confidence?time=hour&num=24</p></div>
      </div>
      <div class="column2">
        <h1>Per Minute<br /> - Raw</h1>
        <div id="graph_container_4" class="graph"><h2># Tweets</h2><p>/game/tweets?time=min&num=1440</p></div>
        <div id="graph_container_5" class="graph"><h2>Positive Mentions</h2><p>/game/pos?time=min&num=1440</p></div>
        <div id="graph_container_6" class="graph"><h2>Confidence</h2><p>/game/confidence?time=min&num=1440</p></div>
      </div>
       <div class="column3">
        <h1>Per Minute<br /> - Smoothed</h1>
        <div id="graph_container_7" class="graph"><h2># Tweets</h2><p>/game/tweets?time=min&num=1440</p></div>
        <div id="graph_container_8" class="graph"><h2>Positive Mentions</h2><p>/game/pos?time=min&num=1440</p></div>
        <div id="graph_container_9" class="graph"><h2>Confidence</h2><p>/game/confidence?time=min&num=1440</p></div>
      </div>
    </div>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script type="text/javascript" charset="utf-8">
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - General Vars - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Vars for graph size.
    var margin = {top: 20, right: 20, bottom: 30, left: 50},
        width = 550 - margin.left - margin.right,
        height = 300 - margin.top - margin.bottom;
    // Our Date parsing format.
    // TODO: right now the way we handle different data streams is by ignorning whole unit measures (ie. 15 minutes, single minutes) instead of treating individual null values. Need to improve code.
    // We have different parsing formats depending on the type of data: daily, hourly, by minute, etc.
    var parseDateFormat1 = d3.time.format("%Y,%m,%d,%H").parse;             // For data per hour. "%-" means it ignores padding, removing the need for zero-padding perhaps?
    var parseDateFormat2 = d3.time.format("%Y,%m,%d,%H,%M").parse;          // For data per minute.
    // Setup X and Y scales.
    var x = d3.time.scale()
        .range([0, width]);
    var y = d3.scale.linear()
        .range([height, 0]);
    // Setup X and Y axis, using the scales.
    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    // Create SVG element for the graphs.
    var graph1 = d3.select("#graph_container_1").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph2 = d3.select("#graph_container_2").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph3 = d3.select("#graph_container_3").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph4 = d3.select("#graph_container_4").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph5 = d3.select("#graph_container_5").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph6 = d3.select("#graph_container_6").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph7 = d3.select("#graph_container_7").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph8 = d3.select("#graph_container_8").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var graph9 = d3.select("#graph_container_9").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("top", 100)
      .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    // Create our new data array for storing properly formatted data for D3.
    var data;           

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Data Setup - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Use the JSON data : this is real data from our API engine, although it is still in development.
    // For the data we currently have, value1 = Broncos (orange), and value2 = Chiefs (red).

    // - - - - - - - - - - - - - COLUMN 1 : per hour, 24 hours, raw
    // Graph 1 : Tweets
    // d3.json("data-nov7chiefsbroncos-tweets-timehour-num24.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Tweet data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/tweets?time=hour&num=24", function(error, json_data) {                         // LIVE DATA
      // console.log("- - - - - - - - - - - - - - - - - - #1 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph1, "value1", "value2", 1);
      // console.log("- - - - - - - - - - - - - - - - - - #1 D3-FORMATTED DATA : ")
      // console.log(data);
    });
    
    // Graph 2 : Positivity
    // d3.json("data-nov7chiefsbroncos-pos-timehour-num24.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Positivity data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/pos?time=hour&num=24", function(error, json_data) {                                // LIVE DATA
      // console.log("- - - - - - - - - - - - - - - - - - #2 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph2, "value1", "value2", 1);
      // console.log("- - - - - - - - - - - - - - - - - - #2 D3-FORMATTED DATA : ")
      // console.log(data);
    });

    // Graph 3 : Confidence
    // d3.json("data-nov7chiefsbroncos-confidence-timehour-num24.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Confidence data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/confidence?time=hour&num=24", function(error, json_data) {                         // LIVE DATA
      // console.log("- - - - - - - - - - - - - - - - - - #3 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph3, "value2", "value1", 1);
      // console.log("- - - - - - - - - - - - - - - - - - #3 D3-FORMATTED DATA : ")
      // console.log(data);
    });

    // - - - - - - - - - - - - - COLUMN 2 : per minute, 1440 minutes, raw
    // Graph 4 : Tweets
    // d3.json("data-nov7chiefsbroncos-tweets-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Tweet data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/tweets?time=min&num=1440", function(error, json_data) {                         // LIVE DATA
      // console.log("- - - - - - - - - - - - - - - - - - #4 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph4, "value1", "value2", 2);
      // console.log("- - - - - - - - - - - - - - - - - - #4 D3-FORMATTED DATA : ")
      // console.log(data);
    });
    
    // Graph 5 : Positivity
    d3.json("data-nov7chiefsbroncos-pos-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Positivity data instead, from Chiefs VS Broncos on November 17.
    // d3.json("http://97.107.131.209:4577/game/pos?time=min&num=1440", function(error, json_data) {                          // LIVE DATA : TODO - live data is broken right now because it doesn't return perfect value pairs. We must handle that error here, at the moment. But right now we're just using manually pruned data in a local file.
      // console.log("- - - - - - - - - - - - - - - - - - #5 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph5, "value1", "value2", 2);
      // console.log("- - - - - - - - - - - - - - - - - - #5 D3-FORMATTED DATA : ")
      // console.log(data);
    });

    // Graph 6 : Confidence
    // d3.json("data-nov7chiefsbroncos-confidence-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Confidence data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/confidence?time=min&num=1440", function(error, json_data) {                         // LIVE DATA
      // console.log("- - - - - - - - - - - - - - - - - - #6 ORIGINAL DATA : ")
      // console.log(json_data);
      format_raw_data(json_data, graph6, "value1", "value2", 2);
      // console.log("- - - - - - - - - - - - - - - - - - #6 D3-FORMATTED DATA : ")
      // console.log(data);
    });    

    // - - - - - - - - - - - - - COLUMN 3 : per minute, 1440 minutes, smoothed
    // Graph 7 : Tweets
    // d3.json("data-nov7chiefsbroncos-tweets-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Tweet data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/tweets?time=min&num=1440", function(error, json_data) {                         // LIVE DATA
      console.log("- - - - - - - - - - - - - - - - - - #4 ORIGINAL DATA : ")
      console.log(json_data);
      format_raw_data(json_data, graph7, "value1", "value2", 2, 3);
      console.log("- - - - - - - - - - - - - - - - - - #4 D3-FORMATTED DATA : ")
      console.log(data);
    });
    
    // Graph 8 : Positivity
    d3.json("data-nov7chiefsbroncos-pos-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Positivity data instead, from Chiefs VS Broncos on November 17.
    // d3.json("http://97.107.131.209:4577/game/pos?time=min&num=1440", function(error, json_data) {                          // LIVE DATA : TODO - live data is broken right now because it doesn't return perfect value pairs. We must handle that error here, at the moment. But right now we're just using manually pruned data in a local file.
      console.log("- - - - - - - - - - - - - - - - - - #5 ORIGINAL DATA : ")
      console.log(json_data);
      format_raw_data(json_data, graph8, "value1", "value2", 2, 3);
      console.log("- - - - - - - - - - - - - - - - - - #5 D3-FORMATTED DATA : ")
      console.log(data);
    });

    // Graph 9 : Confidence
    // d3.json("data-nov7chiefsbroncos-confidence-timemin-num1440.json", function(error, json_data) {                            // RECORDED DATA : use this recorded Confidence data instead, from Chiefs VS Broncos on November 17.
    d3.json("http://97.107.131.209:4577/game/confidence?time=min&num=1440", function(error, json_data) {                         // LIVE DATA
      console.log("- - - - - - - - - - - - - - - - - - #6 ORIGINAL DATA : ")
      console.log(json_data);
      format_raw_data(json_data, graph9, "value1", "value2", 2, 3);
      console.log("- - - - - - - - - - - - - - - - - - #6 D3-FORMATTED DATA : ")
      console.log(data);
    });    

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Functions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Preprocess the raw data in order to have rows that contain: time, AFC value, NFC value.
    function format_raw_data(raw_data, cur_graph, front_dataset, back_dataset, parse_format, smoothing_amount) {
      data = [];      // clear data array

      // first, check if AFC and NFC have same length
      if (raw_data.afc.length === raw_data.nfc.length) {
        console.log("m- AFC and NFC arrays are same length. Continue to preprocessing the D3-ready data array.");

        // rip out data from the AFC object to populate our new data array (since the AFC and NFC objects have the same structure, we can use either one for building our new array).
        raw_data.afc.map(function (cur_row, index) {
          // console.log(cur_row);
          // console.log(cur_row.time[4]);
          if (parse_format === 1) {
            cur_row.time.splice(4);                                     // TODO: removes the last 2 units for now : the 15-minute and single minute units. Eventually we need to handle them.
          } else if (parse_format === 2) {
            cur_row.time.splice(4, 1);                                  // TODO: remove the 15 minute unit but keep the single minutes, for this time format.
          }

          var new_row = {};                                             // use an object/associative array to store the 3 values of a new row
          new_row["time"] = cur_row.time;                               // store the time
          new_row["value1"] = cur_row.value;                            // store the AFC value as "value1"
          new_row["value2"] = raw_data.nfc[index].value;                // store the related NFC value (at the same current index position) as "value2"
          data.push( new_row );                                         // push the 3 values as a single row, to the new D3 data array
          // console.log(data);
        });
        
        // apply moving-average smoothing, if specified
        if (smoothing_amount !== undefined) {
          moving_window_average(data, smoothing_amount);
        }
        create_graph(cur_graph, front_dataset, back_dataset, parse_format);

      } else {
        console.log("m- ************* PROBLEM ************* Original AFC and NFC arrays not same length.")
      }
    }

    // rebuild our JSON data array: replace original value1 and value2 values with new averaged ones. The steps param determines size of averaging window (step * 2 = window size).
    function moving_window_average(array, steps) {

      return array.map(function (_, index) {
        console.log("------------------ i : "+ index);
        console.log("BEFORE: _ = ");
        console.log(_);
        // console.log("value1 = "+ _["value1"]);

        // make array of just values in window around current element
        var cur_window = array.slice(index - steps, index + steps + 1);
        
        // filter to get only value1 properties
        var cur_window_value1 = cur_window.map( function(element){ 
          var all_values = d3.values(element);
          return all_values[1]; 
        } );
        // average them into one value
        var result_value1 = (d3.sum(cur_window_value1) / cur_window_value1.length);
        if (isNaN(result_value1)) { result_value1 = _["value1"]; }      // for edge values that return bad numbers, use the original number.
        // console.log("cur_window_value1 = ");
        // console.log(cur_window_value1);

        // filter to get only value2 properties
        var cur_window_value2 = cur_window.map( function(element){ 
          var all_values = d3.values(element);
          return all_values[2]; 
        } );
        // average them into one value
        var result_value2 = (d3.sum(cur_window_value2) / cur_window_value2.length);
        if (isNaN(result_value2)) { result_value2 = _["value2"]; }      // for edge values that return bad numbers, use the original number.
        // console.log("cur_window_value2 = ");
        // console.log(cur_window_value2);
        
        // put new averaged values back into the original array.
        _["value1"] = result_value1;
        _["value2"] = result_value2;
        
        console.log("AFTER: _ = ");
        console.log(_);
        return _;

        // console.log("result = "+ result);  
        // return result;
      });
    }

    // create the graphs/charts
    function create_graph(cur_graph, front_dataset, back_dataset, parse_format) {

      // Setup each row of data by formatting the Date for X, and by converting to a number for Y.
      // data = data.rows;                           // Descend one level to be where the rows are.
      data.forEach(function(d) {
        // console.log("time PRE = "+ String(d.time));
        if (parse_format === 1) {
          d.time = parseDateFormat1(String(d.time));         // "time" is X value.
        } else if (parse_format === 2) {
          d.time = parseDateFormat2(String(d.time));
        }
        d.value1 = +d.value1;                       // "value" is Y value. Converts the value to a number (default is string).
        d.value2 = +d.value2;
        // console.log("time POST = "+ String(d.time));
        // console.log("value1 = "+ d.value1);
        // console.log("value2 = "+ d.value2);
      });

      // set the X and Y domains
      x.domain(d3.extent(data, function(d) { return d.time; }));
      if (cur_graph === graph3) {
        y.domain([
          d3.min(data, function(d) { return Math.min(d.value1, d.value2)/1.3; }),
          d3.max(data, function(d) { return Math.max(d.value1, d.value2); })
        ]);
      } else {
        y.domain([
          d3.min(data, function(d) { return Math.min(d.value1, d.value2); }),
          d3.max(data, function(d) { return Math.max(d.value1, d.value2); })
        ]);
      }
      // console.log("t- * * * * * * * * * * * * * * * * * * The MAX Y value = "+ d3.max(data, function(d) { return Math.max(d.value1, d.value2); }));

      // define fill gradient for Team of value1
      cur_graph.append("linearGradient")
        .attr("id", "first-gradient")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0).attr("y1", y(0))
        .attr("x2", 0).attr("y2", y( d3.max(data, function(d) { return d.value1; }) ))
      .selectAll("stop")
        .data([
          {offset: "0%", color: "white"},
          {offset: "50%", color: "#FF6319"}
        ])
      .enter().append("stop")
        .attr("offset", function(d) { return d.offset; })
        .attr("stop-color", function(d) { return d.color; });

      // define fill gradient for Team of value2
      cur_graph.append("linearGradient")
        .attr("id", "second-gradient")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0).attr("y1", y(0))
        .attr("x2", 0).attr("y2", y( d3.max(data, function(d) { return d.value2; }) ))
      .selectAll("stop")
        .data([
          {offset: "0%", color: "white"},
          {offset: "50%", color: "#C60C30"}
        ])
      .enter().append("stop")
        .attr("offset", function(d) { return d.offset; })
        .attr("stop-color", function(d) { return d.color; });

      // ----------------------------- DATASET IN FRONT -----------------------------
      
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d[front_dataset]);
      })
      .interpolate("linear");

      // Draw the data as area chart.
      cur_graph.append("path")
          .datum(data)
          .attr("class", "area_" + front_dataset)
          .attr("d", area);

      // ----------------------------- DATASET IN BACK -----------------------------
      
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d[back_dataset]);
      })
      .interpolate("linear");

      // Draw the data as area chart.
      cur_graph.append("path")
          .datum(data)
          .attr("class", "area_" + back_dataset)
          .attr("d", area);

      // ----------------------------------------------------------

      // Draw the X-axis of the graph.
      cur_graph.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      // Draw the Y-axis of the graph.
      cur_graph.append("g")
          .attr("class", "y axis")
          .call(yAxis)
        .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .attr("class", "axis-text")
          .text("value");

    }


        
  </script>
  
  </body>
</html>